# Crust100 - 100 Programming Challenges in Rust

Welcome to Crust100 ‚Äî a carefully curated collection of programming problems designed to give you hands-on experience with Rust, deepen your understanding of its core concepts, and prepare you for Rust-related job interviews.

## üåü Why this project?

As an experienced C++ developer diving into Rust, I realized the best way to master a language is through practical problem-solving. This project isn't just about writing basic "Hello, World!" programs ‚Äî it‚Äôs a structured roadmap of challenges ranging from beginner-friendly tasks to advanced systems programming.

## üìö What you'll learn

By completing these 100 challenges, you will:

- Gain hands-on experience with Rust‚Äôs core concepts like ownership, borrowing, lifetimes, and pattern matching.
- Implement a wide range of data structures (linked lists, trees, hash maps, etc.).
- Tackle algorithms (sorting, searching, dynamic programming).
- Dive into concurrency (threads, async/await, channels).
- Build real-world applications like HTTP servers, blockchain simulations, and parsers.
- Strengthen problem-solving skills critical for Rust job interviews.

## üèãÔ∏è‚Äç‚ôÄÔ∏è Challenge structure

The challenges are divided into three phases:

1. [**Rust Fundamentals (1‚Äì20)**](#-phase-1-rust-fundamentals-120) ‚Äî Core concepts and simple data structures.
2. [**Intermediate Concepts (21‚Äì50)**](#-phase-2-intermediate-concepts-2150) ‚Äî Ownership, lifetimes, concurrency, and common algorithms.
3. [**Advanced Challenges (51‚Äì100)**](#-phase-3-advanced-challenges-51100) ‚Äî Systems programming, async Rust, unsafe code, and complex algorithms.

## ‚úÖ Progress

**Solved:** 0  
**In Progress:** 0  

### üöÄ Phase 1: Rust Fundamentals (1‚Äì20)

**Goal:** Strengthen your understanding of Rust's core concepts.

- ‚è≥ Implement a simple number guessing game.
- [ ] Create a program that reverses a string without using built-in methods.
- [ ] Build a basic calculator supporting +, -, *, /.
- [ ] Implement a function to count occurrences of each character in a string.
- [ ] Write a function that returns the largest number in an array.
- [ ] Create a struct Rectangle with methods to calculate area and perimeter.
- [ ] Implement a basic linked list with push and display methods.
- [ ] Build a CLI app to convert temperatures between Celsius and Fahrenheit.
- [ ] Create an enum for days of the week and print a custom message for each.
- [ ] Simulate a simple bank account with deposit, withdraw, and balance methods.
- [ ] Implement a stack using vectors.
- [ ] Implement a queue using linked lists.
- [ ] Write a function to check if a string is a palindrome.
- [ ] Build a program that counts words in a file.
- [ ] Implement a basic Result type error handling scenario for division by zero.
- [ ] Create a simple password generator with options for length and complexity.
- [ ] Implement a binary search algorithm.
- [ ] Build a mini ‚Äútodo‚Äù CLI app with add, remove, and list features.
- [ ] Create a program that reads a file and prints its contents to the console.
- [ ] Simulate rolling a dice and keep track of the results using a HashMap.

### üî• Phase 2: Intermediate Concepts (21‚Äì50)

**Goal:** Dive deeper into Rust's core mechanics ‚Äî ownership, lifetimes, and concurrency.

- [ ] Implement a singly linked list with full CRUD operations.
- [ ] Build a Point struct and overload operators for addition and subtraction.
- [ ] Create a program that reads a CSV file and parses it into structs.
- [ ] Implement a binary search tree (BST) with insert and search operations.
- [ ] Simulate a simple pub-sub (publisher-subscriber) system using channels.
- [ ] Build a simple HTTP server using std::net.
- [ ] Implement a thread pool to manage concurrent tasks.
- [ ] Create a "FizzBuzz" solver using iterators and closures.
- [ ] Write a program that uses lifetimes explicitly to handle dangling references.
- [ ] Implement a hash table from scratch using arrays and linked lists.
- [ ] Build a rate limiter for an API using async programming.
- [ ] Implement a graph using adjacency lists.
- [ ] Write a program to solve the N-Queens problem using backtracking.
- [ ] Create a "snake" game in the terminal using Rust.
- [ ] Implement a simple LRU cache.
- [ ] Use Rust's serde to serialize and deserialize JSON data.
- [ ] Build a CLI-based file explorer with tree-like navigation.
- [ ] Implement a merge sort algorithm.
- [ ] Create a simple key-value store backed by a file (mini database).
- [ ] Simulate a simple job scheduler using multithreading.
- [ ] Implement an observer pattern in Rust.
- [ ] Build a library for matrix operations.
- [ ] Write a Bloom filter for checking set membership.
- [ ] Implement a circular buffer.
- [ ] Create a rate-limited logger using Rust's log crate.
- [ ] Build a Rust macro that generates getter/setter methods for a struct.
- [ ] Implement a basic chatbot using pattern matching and string processing.
- [ ] Write a simple task executor with async/await.
- [ ] Build a parser for simple math expressions like 2 + 3 * (4 - 1).
- [ ] Create a thread-safe counter using Mutex.

### üåü Phase 3: Advanced Challenges (51‚Äì100)

**Goal:** Master systems programming, unsafe Rust, and advanced algorithms.

- [ ] Implement a thread-safe linked list.
- [ ] Build a simple blockchain with transaction validation.
- [ ] Implement Dijkstra's shortest path algorithm.
- [ ] Write a concurrent file downloader using async tasks.
- [ ] Implement a simple memory allocator using unsafe Rust.
- [ ] Build a priority queue using a binary heap.
- [ ] Create a small virtual machine that executes bytecode.
- [ ] Implement the Rabin-Karp string matching algorithm.
- [ ] Build a simple actor model framework.
- [ ] Implement a red-black tree.
- [ ] Create a simple peer-to-peer chat application.
- [ ] Build a URL shortener with a hashmap backend.
- [ ] Implement a WebSocket server using tokio.
- [ ] Write a garbage collector using reference counting (Rc and Arc).
- [ ] Build a Redis-like in-memory key-value store.
- [ ] Implement a double-ended queue (Deque).
- [ ] Write a program that finds strongly connected components in a graph.
- [ ] Create a simple regex engine from scratch.
- [ ] Implement the A* search algorithm.
- [ ] Build a basic game engine loop.
- [ ] Write a parser combinator library.
- [ ] Implement the Knuth-Morris-Pratt (KMP) string search algorithm.
- [ ] Create a small TCP proxy server.
- [ ] Build a WebAssembly (WASM) module in Rust.
- [ ] Implement a memory-safe thread pool with lifetimes.
- [ ] Write a program that solves the traveling salesman problem.
- [ ] Build an event loop similar to Node.js.
- [ ] Implement a min-max algorithm for a tic-tac-toe AI.
- [ ] Create a simple HTTP client using hyper.
- [ ] Write a static site generator.
- [ ] Build a filesystem explorer using std::fs.
- [ ] Implement an async work queue.
- [ ] Create a simple caching layer with TTL (Time To Live).
- [ ] Build a Rust plugin system using dynamic linking.
- [ ] Implement a Huffman encoding algorithm.
- [ ] Write a program to detect race conditions in concurrent code.
- [ ] Build a library for graph algorithms (DFS, BFS, etc.).
- [ ] Implement a WebRTC signaling server.
- [ ] Create a simple Rust profiler for measuring execution times.
- [ ] Write a program to solve Sudoku using backtracking.
- [ ] Build a gRPC server with Rust.
- [ ] Implement a self-balancing AVL tree.
- [ ] Create a lock-free stack using atomic operations.
- [ ] Build a chat server using Rust and Tokio.
- [ ] Implement an in-memory trie for autocomplete.
- [ ] Write a distributed key-value store.
- [ ] Create a peer-to-peer file-sharing application.
- [ ] Implement a SAT solver.
- [ ] Build a Rust-based HTTP reverse proxy.
- [ ] Create a small scripting language interpreter in Rust.

## ü¶Ä Contributions

Want to suggest a new challenge or improve an existing one? Contributions are welcome! Feel free to submit a PR or open an issue.

## ‚≠ê Let‚Äôs connect

Follow my Rust journey on GitHub and feel free to star this repo if you find it useful! If not, kindly give your valuable feedback.
